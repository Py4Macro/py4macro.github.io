#!/usr/bin/env python
# coding: utf-8

# (chap:18-adas)=
# # 景気循環の定量分析：ADASモデル

# <div name="html-admonition" style="font-size: 0.8em">
# <input type="button" onclick="location.href='https://translate.google.com/translate?hl=&sl=ja&tl=en&u='+window.location;" value="Google translation" style="color:#ffffff;background-color:#008080; height:25px" onmouseover="this.style.background='#99ccff'" onmouseout="this.style.background='#008080'"/> in English or the language of your choice.
# </div><br>

# In[1]:


import japanize_matplotlib
import numpy as np
import pandas as pd
import py4macro
import statsmodels.formula.api as smf


# ## はじめに

# 本章の目的は，回帰分析，差分方程式，ランダム変数を駆使し，景気循環データに基づき定量（数量）マクロ経済分析をおこなうことである。使うモデルは，中級レベルのマクロ経済学ではお馴染みの総需要・総供給モデル（ADASモデル）ある。また，ここでの定量分析とは，ADASモデルの数量的な特徴を確認し，次の問いを検討することである。
# 
# > GDPと価格水準の％乖離の変動は，何パーセントが需要ショックにより引き起こされ，何パーセントが供給ショックに起因するのか？
# 
# 通常の教科書でのADASモデルを使う分析では，パラメータの符号（正か負）のみを仮定し，比較静学に基づきモデルの定性的な特徴や予測を考察する。例えば，政府支出の増加を考えてみよう。利子率は上昇し，短期的にはGDPも増加することになるが，「GDPの増加」は定性的な結果（予測）である。このような分析は経済を理解する上で有用な方法であるが，例えば，「GDPがどれだけ増加するのか」について答えることはできない。GDPの増加分がどれ程になるのかは，定量的な問題（予測）であり，総需要曲線と総供給曲線の傾き等の値を設定してこそ答えることができる問いである。
# 
# 一方で，パラメータにランダムな値を使っても意味がある分析にはならない。そこで有用な手法がカリブレーションと呼ばれる分析方法である。詳細は以下で説明するが，簡単に言うと，カリブレーションではマクロ・データの特徴に基づきパラメータの値を決定することになる。一旦，パラメータの値が決まると定量的な分析が可能となる。以下では次の分析をおこなう。

# 第一に，ADASモデルの安定性を検討する。ADASモデルの定性的分析をとおして長期的な均衡は安定的だと直感的に理解できるが，以下では，差分方程式を使い結果をプロットし均衡の安定性を確認する。これにより，均衡への収束の速さを視覚的に確認することも可能となる。第二に，インパルス反応関数を使い，需要ショックもしくは供給ショックが発生した際，産出量と物価水準（トレンドからの％乖離）がどのように変化するかを示す時系列的なプロットに基づき検討する。このような定量的な分析は，ADASモデルの定性的な理解を補完することになる。第三に，確率的シミュレーションをおこない，ADASモデルが景気循環データを再現できるかを検討する。確率的シミュレーションでは，毎期毎期，需要・供給ショックが絶え間なく発生する状況を考え，生成されるデータと実際の景気循環データの特徴を比較することにより，ADASモデルのデータ再現力を評価することができる。第四に，確率的シミュレーションの結果を踏まえて，上述の定量的な問いを検討する。

# ## ADASモデル

# ここでは総需要・総供給モデル（ADASモデル，Aggregate Demand and Aggregate Supply Model）の記号を整理し，景気循環データと整合性が保たれるように内生変数を解釈し直すことにより，定量分析の準備をおこなう。

# ### モデルの構造

# #### 短期総供給曲線（AS曲線）

# $$
# P_t=P_{t}^e+a(Y_t-Y_{*})+v_t,\qquad a>0
# $$(eq:18-as)

# * $Y_t=$ 産出量の対数
# * $Y_{*}=$ 自然産出量の対数
#     * 資本蓄積や技術進歩などにより決定される。
#     * トレンドに対応する。
#     * ADASモデルでは一定と仮定する。下で仮定する需要ショックは一時的なものであり，トレンドには影響しないと仮定する。
# * $P_t=$ 物価水準の対数
# * $P_{*}=$ 物価水準の対数
#     * トレンドに対応する。
#     * ここでは一定と仮定する。下で仮定する供給ショックは一時的なものであり，トレンドには影響しないと仮定する。
# * $v_t=$ 供給ショック

# 式[](eq:18-as)自体はAS曲線の典型的な式となっている。一方で，定量分析のために次の点に関して解釈し直している。
# * 変数の定義：
#     * 内生変数である$Y_t$と$P_t$は産出量と物価水準の対数としている。同様に，$Y_{*}$，$P_{*}$，$P_t^{e}$も対数としている。対数として解釈することにより，ADASモデルを使ってデータを捉えやすくする利点があるためである。
# * 産出量の長期的水準：
#     * 長期均衡での産出量は自然産出量$Y_{*}$で与えられるが，これはGDPのトレンドと解釈する。以下の分析では，PHフィルターで計算した値を使うことになる。
#     * 通常のADASモデルの仮定に沿って，総供給ショック$v_t$は$Y_{*}$に影響を与えないとする。即ち，ここでの総供給ショックは，産出量と物価水準がトレンドから乖離する要因となるものであり，その効果は長期的な効果はないと仮定する。言い換えると，トレンドに影響を及ぼす供給ショックもあり得る訳だが，それらは対象とはなっていないことになる。
# * 物価水準の長期的水準：
#     * ADASモデルでの長期的な物価水準とは$Y_t=Y_{*}$が満たされる$P_t$であり，基本的にはどのような値をとっても構わない。例えば，総供給ショック$v_t$が`0`から`0.5`に増加（不利な総供給ショック）し，`0.5`が永続的に続く場合，長期的な物価水準は永続的に高くなる。しかし，ここで考える総供給ショック$v_t$は一過性のショックと仮定する。即ち，ある時は`0.3`や`-0.1`などの値を取るが，それは短期的な現象であり，長期的には`0`に戻ると仮定する。この仮定により，長期的な物価水準$P_{*}$が存在することになり，それを物価水準のトレンドだと解釈する。産出量と同様に，HPフィルターを使って物価水準の長期的なトレンドを算出することになる。

# #### 総需要曲線（AD曲線）

# $$
# Y_t=b-c P_t + u_t, \qquad b,c>0
# $$(eq:18-ad)
# 
# * $u_t=$ 総需要ショック

# AD曲線はIS-LMモデルから導出することができるが，その場合，政府支出やマネーストックなど様々な変数に依存した複雑な式となる。式[](eq:18-ad)は対数線形の簡単な式となっているが，その裏にあるのが次の考え方である。
# * 政府支出や租税，マネーストック，更には，消費や投資水準はパラメータである$b$と$c$に含まれていると考える。また，それらの変化は全て総需要ショック$u_t$が捉えていると仮定する。
# * 総供給ショック$v_t$と同様に，総需要ショック$u_t$は長期的な産出量水準には影響は与えないと仮定を置くとともに，ショック自体も永続的に維持されるのではなく，時間とともにフェードアウトする短期的ショックと仮定する。
# 
# このように簡略化することにより，景気循環データをADASモデルの枠組みの中で扱いやすくなる利点がある。

# #### 適応的期待

# $$
# P_t^e= P_{t-1}
# $$(eq:18-pe)
# 
# 適応的期待は「後ろ向き」の期待形成を仮定することになり，批判の的にもなり易い。しかし，最前線の研究でも取り上げられる場合があり，データの特徴を捉えた仮定と言えるだろう。

# #### 総需要・総供給ショック

# 既に触れたが，ショック項$u_t$と$v_t$は次の2点を満たすと仮定する。
# * 自然産出量$Y_{*}$に影響を及ぼさない。
# * 短期的なショックであり，永続的に正または負の一定の値を取り続けない。
# 
# この２つの仮定は，$u_t$または$v_t$が`0`以外の値を取った場合，`0`に戻せば満たされることになる。
# 
# 一方で，確率的シミュレーションを行う際は，毎期毎期において総需要ショックと総供給ショックが発生する状況を考える。その場合，次の２つの仮定の内の一つを採用することになる。
# 1. ホワイト・ノイズ
# 
# $$
# \begin{align*}
# u_t&\sim\text{N}(0,\sigma_u^2)\\
# v_t&\sim\text{N}(0,\sigma_v^2)
# \end{align*}
# $$
# 
# 2. AR(1)自己回帰モデル
# 
# $$
# \begin{align*}
# u_t&=\rho_u u_{t-1}+e_{ut},\qquad u_t\sim\text{N}(0,\sigma_{eu}^2)\\
# v_t&=\rho_v v_{t-1}+e_{vt},\qquad v_t\sim\text{N}(0,\sigma_{ev}^2)
# \end{align*}
# $$

# この章でおこなう確率的シミュレーションではホワイト・ノイズを仮定するが，AR(1)を使う場合は付録で扱うことにする。

# #### 長期均衡

# 長期均衡または定常状態（steady state）では次の条件が満たされることになる。
# * $u_{t}=v_t=0$：ショックはない
# * $P_t=P_*$
# * $Y_t=Y_*$

# #### 図示

# ADASモデルを図示すると{numref}`fig:18-adas0`のようになる。長期均衡においてAD曲線とAS曲線は$P_*$と$Y_*$で交差することになる。短期均衡を考えるために，総供給ショック$v_t$が１期間だけ正の値を取り，その後は`0`になるとしよう。ショックが発生するとAS曲線は上方シフトし，産出量は減少し物価水準は上昇する。適応的期待により，ショックがなくなってもAS曲線は直ぐには長期均衡に戻らず，徐々に下方シフトすることになり，最終的には長期均衡に経済は戻ることになる。
# 
# このような分析は，教科書で解説される典型的な例である。長期均衡は安定的であり，産出量と物価水準は少しずつ動くという結果は直感的であり，わかり易い。しかし，このような定性的な分析からは，ショック発生後に経済はどれだけの時間をかけて長期均衡に戻るかについては何もわからない。また，長期均衡に戻るスピードが何に依存しているのかも分からない。AD曲線とAS曲線の傾きが影響を及ぼしそうだと想像できるが，傾きが急だと戻るスピードが早いのだろうか，遅いのだろうか。このような問は，定量分析をおこなうことにより簡単に確認することが可能となる。

# ```{figure} /images/adas0.jpg
# ---
# scale: 10%
# name: fig:18-adas0
# ---
# 産出量と物価水準で表したADASモデル
# ```

# ### 均衡式

# ADASモデルとデータと整合性があるようにするために次の変数を定義しよう。
# * $p_t=P_t-P_*$：価格水準のトレンドからの％乖離
# * $y_t=Y_t-Y_*$：産出量のトレンドからの％乖離
# 
# $p_t$と$y_t$を使ってAS曲線とAD曲線を書き換えることにする。

# #### AS曲線

# 式[](eq:18-as)に式[](eq:18-pe)を使い次の１行目となる。
# 
# $$
# \begin{align*}
# P_{t}&=P_{t-1}+a(Y_{t}-Y_{*})+v_t \\
# &\Downarrow\quad\text{両辺から$P_{*}$を引く}\\
# P_{t}-P_{*}&=(P_{t-1}-P_{*})+a(Y_{t}-Y_{*})+v_t
# \end{align*}
# $$
# 
# $$
# \begin{align*}
# &\Downarrow\quad\text{上の定義を使う}\\
# p_t &= p_{t-1}+ay_t +v_t
# \end{align*}
# $$(eq:18-as_small)

# この式はAS曲線を産出量と物価水準のトレンドからの％乖離で表している。また，この式から次のことが言える。
# * $p_{t-1}$と$y_t$を所与とすると，総供給ショック$v_t$の１単位は物価水準のトレンドからの乖離を１％発生させる。

# #### AD曲線

# まず長期均衡でのAD曲線を考えてみよう。
# 
# $$
# Y_{*}=b-c P_{*} 
# $$ (eq:18-adss)
# 
# $u_t=0$となるため，上の式が成立することになる。

# 次に，式[](eq:18-ad)の両辺から$Y_{*}$を引くと次式となる。
# 
# $$Y_t-Y_*=b-Y_*-c P_t + u_t$$
# 
# また左辺の$b-Y_{*}$を削除するために式[](eq:18-adss)を使うと
# 
# $$
# Y_t-Y_*=cP_*-c P_t + u_t
# $$
# 
# となり，上の定義を使い次式を導出できる。
# 
# $$
# y_t=-cp_t + u_t
# $$ (eq:18-ad_small)

# この式はAD曲線を産出量と物価水準のトレンドからの％乖離で表している。また，この式から次のことが言える。
# * $p_{t}$を所与とすると，総需要ショック$u_t$の１単位はGDPのトレンドからの乖離を１％発生させる。

# #### 長期均衡

# 長期均衡または定常状態（steady state）では次の条件が満たされることになる。
# * $u_{t}=v_t=0$：ショックはない
# * $p_* =0$：トレンドからの％乖離はゼロ
# * $y_* =0$：トレンドからの％乖離はゼロ

# #### 図示

# ADASモデルを％乖離の変数$p_t$と$y_t$で表した図が{numref}`fig:18-adas1`である。原点が長期均衡となる。{numref}`fig:18-adas0`と同じように，総供給ショック$v_t$が１期間だけ正の値を取り，その後は`0`になる場合を考えてみよう。ショックが発生するとAS曲線は上方シフトし，産出量の％乖離は負の値となるが，物価水準の％乖離は正の値を取ることになる。ショックが`0`に戻った後，AS曲線は徐々に下方シフトし，最終的には長期均衡（原点）に経済は戻ることになる。以下の分析では，％乖離の変数である$p_t$と$y_t$を使うが，{numref}`fig:18-adas1`を念頭に置き結果を解釈するとわかり易いだろう。

# ```{figure} /images/adas1.jpg
# ---
# scale: 10%
# name: fig:18-adas1
# ---
# 産出量と物価水準のトレンドからの％乖離で表したADASモデル
# ```

# ## 景気循環のデータ

# この章では式[](eq:18-as_small)と式[](eq:18-ad_small)を使い定量分析をおこなうが，まず，それらの式と整合性があるデータの特徴を考える。$y_t$と$p_t$はトレンドからの％乖離となるため，`py4macro`の`trend()`関数を使い，対応する変数を作成することにする。

# In[2]:


df = py4macro.data('jpn-q')


# In[3]:


df.columns


# $Y_t$には`gdp`を使い，$P_t$には`deflator`を使うことにする。
# 
# 次のコードで作成する`gdp_cycle`と`deflator_cycle`は，`0`を中心に上下する系列となる。

# In[4]:


for c in ['gdp','deflator']:
    
    df[c+'_cycle'] = np.log(df[c]) - py4macro.trend( np.log(df[c]) )
    
df.head()


# `gdp_cycle`と`deflator_cycle`をプロットし，データのイメージを掴んでおこう。

# In[5]:


ax_ = df.loc[:,['gdp_cycle','deflator_cycle']].plot()
ax_.axhline(0, color='red')
pass


# 以下では，`gdp_cycle`と`deflator_cycle`の３つの特徴に焦点を当て議論を進めることにする。

# ### データの特徴１

# In[6]:


y_std = df.loc[:,'gdp_cycle'].std()
p_std = df.loc[:,'deflator_cycle'].std()
print(f'GDPのトレンドからの％乖離の標準偏差：{y_std:.6f}')
print(f'デフレータのトレンドからの％乖離の標準偏差：{p_std:.6f}')

# 不偏分散の平方根


# ２つの数値を比べると，GDPの％乖離の標準偏差はデフレーターの約2倍あることが分かる。これは上のプロットで`gdp_cycle`の変動幅が大きいことを反映している。

# ### データの特徴２

# In[7]:


y_autocorr = df.loc[:,'gdp_cycle'].autocorr()
p_autocorr = df.loc[:,'deflator_cycle'].autocorr()
print(f'GDPのトレンドからの％乖離の自己相関係数：{y_autocorr:.3f}')
print(f'デフレータのトレンドからの％乖離の自己相関係数：{p_autocorr:.3f}')


# デフレータの方がより高い持続性（persistence; 慣性とも訳される）があることを意味する。

# **データの特徴３**

# In[8]:


yp_corr = df.loc[:,['gdp_cycle', 'deflator_cycle']].corr().iloc[0,1]
print(f'GDPとデフレータの％乖離の相関係数：{yp_corr:.3f}')


# この値は同じ期の相関係数であり，絶対値は小さく弱い関係にある。しかし，直感的には`gdp_cycle`と`deflator_cycle`の正の相関をイメージするのではないだろうか。正のGDPの％乖離は景気が良いことを示しているため，物価水準であるデフレーターもトレンドから正の方向に乖離するのではないか，という考えである。そのような考え方は基本的には正しいと言えるだろう。ただ，データを見る限り時間のズレがあるようだ。プロットを見ると，正の方向にGDPの％乖離が発生した後にデフレーターの正の乖離が発生しているように見える。次のプロットは，$t$期の`gdp_cycle`と$t+6$期の`deflator_cycle`を重ねて図示している。同じ方向に動いていることを示しているとともに，相関係数も約`0.46`となっており，正の相関を数値でも確認できる。一つの可能性として次の解釈が成り立つ。デフレーターの変化には時間がかかり，それは価格の粘着性の反映かもしれない。

# In[9]:


t_shift = 6
tmp = df.copy()
tmp['deflator_cycle_shift'] = tmp['deflator_cycle'].shift(-t_shift)
ax_ = tmp[['gdp_cycle', 'deflator_cycle_shift']].plot()
ax_.axhline(0, color='red')
yp_corr_shift = tmp[['gdp_cycle', 'deflator_cycle_shift']].corr().iloc[0,1]
print(f'GDPと{t_shift}期先のデフレータの％乖離の相関係数：{yp_corr_shift:.3f}')


# これらのデータの特徴１〜３をどこまで**再現**できるかに基づいてADASモデルを評価することになる。

# ## カリブレーション

# ### はじめに

# 定量分析を進めるためには，ADASモデルのパラメータに値を設定する必要がある。
# ここでは景気循環のデータに基づき，次の4つのパラメーターの値を決めていく
# * $a$，$c$，$\sigma_u$，$\sigma_v$ （標準偏差）
# 
# パラメーターの値の決め方には主に次の２つある。
# 1. データに基づいて計量経済学的な手法などを用いて推定した結果を使う。
# 1. 既存の実証研究で報告され推定値を使う。
# 
# 多くの研究の場合，これらの方法を駆使して値を決めることになる。
# また，必ずしも対象の経済モデルに基づいた推定結果でなくとも構わない。
# 以下では１番目の方法を使い議論を進めることにする。

# ### カリブレーションとは

# ２つの体重計があるとしよう。
# 一つは，市販の正確な体重計で誤差はない。
# もう一つは自作の体重計で，作ったばかりなので精度に欠ける。
# 自作体重計にはスイッチが取り付けられており，それを調整することにより誤差を小さくし精度を高めることができる。
# そのスイッチの使い方は次のようになる。
# まず市販の体重計で自分の体重を測る。
# 次に自作体重計で測り同じ数値が出るようにスイッチを調整する。
# このように，基準となる機器に基づいて測定器の誤差をなくすための調整をおこなうことを**カリブレーション**と呼ぶ。
# 自分の体重を使ってカリブレーションをおこない，親族や友達が使っても体重を正確に測れる場合は，手作り体重計の成功ということである。
# 一方で，自分以外の体重を測ると誤差が残る場合は，手作り体重計は100％成功とは言えないだろう。
# 60kg以上の体重は誤差が大きいが，60kg未満であればある程度の精度が確保できている場合はどうだろうか。
# 「60kg未満の体重を測る」が目的である場合，手作り体重計の成功と考えることもできるだろう。
# 
# このカリブレーションという手法は，最近のマクロ経済学の研究で広く使われており，その分野を定量的（数量的）マクロ経済学と呼ぶ。
# ここではAD-ASモデルに応用しようというのが目的である。
# 体重計の例を使うと，AD-ASモデルと実際経済の関係は次のようになる。
# * 市販の正確な体重計　→　日本経済
# * 手作り体重計　→　ADASモデル
# * 手作り体重計のスイッチ　→　ADASモデルのパラメーター（外生変数）
# * スイッチの調整　→　パラメーターの値の設定
# * カリブレーションで使うデータ
#     * 自分の体重　→　景気循環に関する特徴
# * 評価方法
#     * 他の人の体重を測り手作り体重計の誤差を確認　→　ADASモデルのパラメーターの設定に使われていないデータをどれだけ説明できるかの確認

# ### 均衡式の整理

# 式[](eq:18-as_small)と[](eq:18-ad_small)を再掲する。
# 
# $$
# p_{t}=p_{t-1}+ay_{t}+v_{t}
# $$ (eq:18-as_small2)
# 
# 
# $$
# y_t=-c p_t + u_t
# $$ (eq:18-ad_small2)
# 
# 式[](eq:18-ad_small)を式[](eq:18-as_small)に代入することにより，次のように整理することができる。

# $$\begin{align*}
# p_{t}
# &=p_{t-1}+a(-c p_{t} + u_{t})+v_{t} \\
# (1+a c)p_{t}&=p_{t-1} +a u_{t}+v_{t} \\
# p_{t}&=h p_{t-1}+h\left(a u_{t}+v_{t}\right)
# \end{align*}$$
# 
# ここで
# 
# $$
# h\equiv\frac{1}{1+a c}<1
# $$ (eq:18-h)

# この結果を利用して，以下ではADASモデルを次の２つの式で表すことにする。

# $$
# p_{t}=hp_{t-1}+h\left(a u_{t}+v_{t}\right)
# $$ (eq:18-eq-p)
# 
# $$
# y_t=-cp_t + u_t
# $$ (eq:18-eq-y)

# この均衡式の特徴：
# * 式[](eq:18-eq-p)のみで$p_t$が決定され，$p_t$が与えられると式[](eq:18-eq-y)で$y_t$の値が決まる構造となっている。
# * 式[](eq:18-eq-p)は差分方程式だが，式[](eq:18-eq-y)は差分方程式ではない。従って，長期均衡の安定性は式[](eq:18-eq-p)のみによって決定されることになる。

# ### 準備：$h$の推定値

# 均衡式[](eq:18-eq-p)は$p_t$の差分方程式となっており，次のような自己回帰モデルとなっている。
# 
# $$
# p_{t}=hp_{t-1} + e_{pt}
# $$ (eq:18-regression-h)
# 
# * $e_{pt}\equiv h\left(a u_{t}+v_{t}\right)$
# 
# 式[](eq:18-regression-h)を回帰式と捉えて$h$を推定する。
# 説明変数である$p_{t-1}$は誤差項$e_t$とは期間がズレているため相関していないことが分かる。
# 
# まず，`df`のメソッド`.shift()`を使って`deflator_cycle`を１期ずらした列を`deflator_cycle_lag`として`df`に追加しよう。

# In[10]:


df['deflator_cycle_lag'] = df['deflator_cycle'].shift()
df.iloc[:5,-5:]


# `deflator_cycle_lag`には１期前の`deflator_cycle`の値が並んでいるのが確認できる。
# 
# まず回帰分析をおこない，その結果を表示する。

# In[11]:


res_h = smf.ols('deflator_cycle ~ deflator_cycle_lag', data=df).fit()
print(res_h.summary())


# **＜推定結果について＞**

# * AR(1)は弱従属的となるため，$h$の推定値である$\hat{h}$は不偏性は満たさないが一致性を満たす。
# * `Durbin-Watson`は`1.686`であり残差の系列相関は排除できる。
# * 残差の均一分散
#     * ブルーシュペーガン検定とホワイト検定を使うと，帰無仮説（均一分散）は「通常」の優位性水準ではを棄却される。
#     * 不均一分散頑健推定（`HC`）を使うと推定値`h`の`t`検定は有効になるが，その場合の推定値の統計的優位性は高いことが確認できる。
# * 定数項なしで推定しても結果は殆ど変わらない。

# 式[](eq:18-eq-p)は`AR(1)`であるため，$\hat{h}$は$p_t$の自己相関係数でもあり，非常に高い持続性が特徴となっている。
# 
# 以下に続く分析のために，次の変数を作成しておこう。

# In[12]:


hhat = res_h.params[1]  # hの推定値
ep = res_h.resid        # 推定式(3)の残差


# ### 最初のスイッチ：$c$の値

# ここでは`hhat`を利用して`c`の推定値を計算する。
# 均衡式[](eq:18-eq-p)を[](eq:18-eq-y)に代入しよう
# 
# $$
# y_t = dp_{t-1} + e_{yt}
# $$ (eq:18-regression-d)
# 
# * $d\equiv -ch$
# * $e_{yt}\equiv (1-ach)u_t-chv_t=\left(1-\dfrac{ac}{1+ac}\right)u_t-chv_t=hu_t-chv_t$
# 
# 式[](eq:18-regression-d)を推定式として$d$の推定値を計算する。

# In[13]:


res_d = smf.ols('gdp_cycle ~ deflator_cycle_lag', data=df).fit()
print(res_d.summary())


# **＜推定結果について＞**
# * 説明変数$p_{t-1}$は誤差項$e_{yt}$と相関しておらず，定常過程であるため，$d$の推定値は一致性を満たすことになる。
# * `Durbin-Watson`検定量は`0.696`であり残差の正の系列相関が疑われる。
# * 残差の均一分散
#     * ブルーシュペーガン検定とホワイト検定を使うと，帰無仮説（均一分散）は「通常」の優位性水準ではを棄却される。
# * 不均一系列相関頑健推定（`HAC`）を使うと推定値`d`の`t`検定は有効になるが，その場合の推定値の統計的優位性は高いことが確認できる。
# * 定数項なしで推定しても結果は殆ど変わらない。

# $d$の推定値である$\hat{d}$は負であり，モデルに沿った結果である。
# 推定値を`dhat`に割り当てることにする。

# In[14]:


dhat = res_d.params[1]


# ここで重要なのは，$-d\equiv ch$となり，$c$の推定値を次式で計算することができる。
# 
# $$
# \hat{c} = -\frac{\hat{d}}{\hat{h}}
# $$
# 
# この値を`chat`に割り当てよう。

# In[15]:


chat = -dhat / hhat
chat


# これが「最初のスイッチの調整」である。また後に続く計算のために推定結果の残差を割りてて次の変数も作成しておく。

# In[16]:


ey = res_d.resid


# ### ２つ目のスイッチ：$a$の値

# 式[](eq:18-h)では，$h$は$a$と$c$の関数となっている。
# すでに$h$と$c$の推定値を計算しているため，この式を使うことにより簡単に$a$の推定値を計算することができる。
# 式[](eq:18-h)を整理すると次式となる。
# 
# $$
# \hat{a} = \left(\dfrac{1}{\hat{h}}-1\right)\frac{1}{\hat{c}}
# $$
# 
# 計算結果を`ahat`に割り当てよう。

# In[17]:


ahat = (1/hhat - 1) / chat
ahat


# これが「2つ目のスイッチの調整」である。

# ### ３つ目のスイッチ：$\sigma_v$の値

# $\sigma_v^2$の値も回帰式の結果を使い設定する。
# 式[](eq:18-regression-h)の誤差項$e_{pt}$は$u_t$と$v_t$の線形関数となっており，同様に，式[](eq:18-regression-d)の誤差項$e_{yt}$も$u_t$と$v_t$の線形関数となっている。
# 以下に再掲する。
# 
# $$
# \begin{align*}
# e_{pt}&=h(a u_{t}+v_{t})\\
# e_{yt}&=h(u_t-cv_t)
# \end{align*}
# $$ (eq:18-ept-eyp)
# 
# これはAD-ASモデルを前提とした理論上の関係であり，全てが観測不可能である。
# しかし，$a$と$h$にはその推定値$\hat{a}$と$\hat{h}$を使い，$e_{pt}$と$e_{yt}$については残差$\hat{e}_{pt}$と$e_{yt}$を用いることにより，$u_t$と$v_t$を求めることが可能である。
# 式[](eq:18-ept-eyp)は$u_t$と$v_t$の線形連立方程式となっているため，簡単に次のように書き直すことができる。
# 
# $$
# \hat{v}_t=\hat{e}_{pt}-\hat{a}\hat{e}_{yt}
# $$ (eq:18-vt)
# 
# $$
# \hat{u}_t=\hat{c}\hat{e}_{pt}+\hat{e}_{yt}
# $$ (eq:18-ut)
# 
# ここで$\hat{e}_{pt}$と$\hat{e}_{yt}$は残差を，$\hat{a}$と$\hat{c}$は推定値を表しており，これらを使って計算した需要・供給ショックを$\hat{v}_t$と$\hat{u}_t$として表している。
# まず式[](eq:18-vt)を使い，結果を`vt`に割り当てよう。

# In[18]:


vt = ep - ahat*ey


# `vt`のデータ型は`Series`であり，メソッド`.std()`を使うと簡単に`vt`の標準偏差を計算することができる。
# 結果を`v_std`に割り当てよう。

# In[19]:


v_std = vt.std()
v_std


# この値を$\sigma_v$に使うことにする。これが「3つ目のスイッチの調整」である。

# ### ４つ目のスイッチ：$\sigma_u$の値

# 同様に，式[](eq:18-ut)を使うと，$\hat{u}_t$の標準偏差を計算することができる。
# `u_std`に割り当てる。

# In[20]:


ut = ey + chat*ep
u_std = ut.std()
u_std


# この値を$\sigma_u$に使うが，これが「最後のスイッチの調整」となる。
# 
# `v_std`と`u_std`を比べると，後者の値がより大きい。
# ADASモデルの枠組みで考えると，需要ショックの変動幅が大きいことを示している。

# ### パラメーターの値：再掲

# In[21]:


print(f'aの値：{ahat:.3f}')
print(f'cの値：{chat:.3f}')
print(f'uの標準偏差：{u_std:.6f}')
print(f'vの標準偏差：{v_std:.6f}')


# 需要ショック（$u_t$）の標準偏差が比較的に大きく，供給ショック（$v_t$）の2倍以上となっている。この結果は，以下で考察する定量的な問に関する結果を理解する鍵となる。

# ## コードの基本形

# 以下ではシミュレーションをおこなうが，コードは関数にまとめて書くことにする。
# コードは次のようなパターンになっている。
# 
# 関数の中身
# 1. アップデート用の変数を用意
# 1. 空のリストを作成
# 1. `for`ループに`.append()`を使う
# 1. `DataFrame`を返す
# 
# 簡単な例として次の差分方程式を考えてみよう。
# 
# $$
# x_t = x_{t-1} + a
# $$
# 
# `my_func()`は，この差分方程式を使った計算結果を`DataFrame`として返す。

# In[22]:


def my_func(x0, a, n):
    """
    引数：
        x0: 初期値
        a: 差分方程式のパラメーター
        n: ループ計算の回数
    戻り値：
        DataFrame
    """

    x = x0      # アップデート用の変数

    lst = [x]   # 空のリスト

    for i in range(n):

        x = x + a      # 差分方程式

        lst.append(x)  # リストに結果を追加
        
    return pd.DataFrame({'col': lst})


# In[23]:


my_func(0, 10, 5)


# 次のセクションのコードは少し長くなるが，コードのパターンとしては上の例と同じになるので，それほど複雑には感じないだろう。

# ## ADASモデルの安定性

# まずADASモデルの安定性を考える。すなわち，任意の初期値（$p_0$と$y_0$）にある経済が長期均衡に戻るかどうかを確認する。
# そのために，ここでは総需要・総供給ショックがない経済を考える。即ち，$u_t=v_t=0$，$t=0,1,2,\cdots$とする。
# 従って，均衡式[](eq:18-eq-p)と[](eq:18-eq-y)は
# 
# $$
# p_{t}=hp_{t-1}
# $$ (eq:18-eq-p-v0)
# 
# $$
# y_t=-cp_t 
# $$ (eq:18-eq-y-u0)
# 
# となる。
# 
# 上でも説明したが，次の特徴がある。$p_t$の値は式[](eq:18-eq-p-v0)のみで決定され，その$p_t$に基づいて$y_t$が式[](eq:18-eq-y-u0)で決まる。この点を説明するために次の表を見てみよう。
# 
# |           | t=0   | t=1   | t=2   | t=3   |... |
# |-----------|-------|-------|-------|-------|----|
# | デフレーター | $p_0$ | $p_1$ | $p_2$ | $p_3$ |... |
# | GDP       | $y_0$ | $y_1$ | $y_2$ | $y_3$ |... |
# 
# * $t=0$期：初期値$p_0$が与えられると，式[](eq:18-eq-y-u0)によって初期値$y_0$が**決定される**。
# * $t=1$期：$p_0$に基づいて式[](eq:18-eq-p-v0)に従って$p_1$が決まる。また$p_1$が決まると，式[](eq:18-eq-y-u0)によって$y_1$が定まる。
# * $t=2$期以降：同様のプロセスで$p_t$と$y_t$が決定される。
# 
# ここから次の２つの特徴が浮かび上がる。
# 1. 初期値には$p_0$のみが必要であり，$y_0$を別に設定する必要はない。
# 1. 安定性は式[](eq:18-eq-p-v0)のみに依存する。
# 
# また，特徴2から次のことも導き出せる。
# 式[](eq:18-eq-p-v0)の$h$の値は正であり絶対値は1よりも小さい。従って，差分方程式である式[](eq:18-eq-p-v0)は安定的であり，ADASモデル自体が安定的だということが確認できる。以下では，シミュレーションを使いこの結果を確認しよう。そのための関数を作成する。

# In[24]:


def adas_model(p0=0, n=20, a=ahat, c=chat):
    """引数
        p0: pの初期値（デフォルト：0）
        n: ループの回数（デフォルト：20）
        a: aの値（デフォルト：ahat）
        c: cの値（デフォルト：chat）
    戻り値：
        yとpのDataFrame"""

    # === pの差分方程式の右辺 ==========
    def price_func(p):
        h = 1/(1+a*c)  # hの値
        return h*p
        
    # === 初期値，forループのアップデート用変数 ==========
    p = p0
    y = -c*p0    
    
    # === yとpの値を格納するリスト ==========
    y_list = [y]   # 初期値を格納
    p_list = [p]   # 初期値を格納

    # === ショック後のループ計算 ==========
    for _ in range(n):
        
        p = price_func(p)
        y = -c*p

        y_list.append(y)
        p_list.append(p)
    
    # === 辞書の作成 ==========
    dic = {'y':y_list, 'p':p_list}
    
    # === 戻り値としてのDataFrame ==========
    return pd.DataFrame(dic)


# デフレーターの％乖離の初期値を1（即ち，１％乖離）として結果をプロットしてみよう。

# In[25]:


adas_model(p0=1).plot(marker='.')
pass


# このプロットの横軸には返された`DataFrame`の行インデックスが使われているが，時系列的なプロットと考えれば良いだろう。$p_t$は初期値である１から始まっており，$y_t$の初期値は式[](eq:18-eq-y-u0)で計算した値である。このプロットから次のことが確認できる。
# * 定常状態である0に両変数は近づいている。即ち，長期均衡が安定的だということである。
# * 長期均衡に近づく速度は，最初は速いが，そのスピードが時間と共に落ちているのが伺える。
# 
# 下のプロットは，横軸に$y_t$，縦軸に$p_t$を置いた図となる。点はAD曲線とAS曲線の交点を表している。右下がりの直線はAD曲線と等しく，AD曲線に沿ってAS曲線が下方シフトしていることになる。そういう意味では，{numref}`fig:18-adas1`で描かれている状況と同じである。

# In[26]:


adas_model(p0=1).plot('y', 'p', marker='.')
pass


# また，このプロットから長期均衡$(0,0)$に近づくにつれて，経済の動きが小刻みになっているのも確認できる。$p_t$と$y_t$の変化が小さくなり，動くスピードが遅くなっている。実は，式[](eq:18-eq-p-v0)を使うと，$p_t$が０に近づく変化率を簡単に計算することができる。式[](eq:18-eq-p-v0)を次のように書き直そう。
# 
# $$
# p_t\text{の変化率}=
# \frac{p_t}{p_{t-1}}-1=h-1=-\frac{a}{1/c+a}<0
# $$

# 負の符号は，時間と共に$p_t$の絶対値が小さくなることを意味している（$p_t$が負の値でも同じ）。また$p_t$の変化率の絶対値は，$a$の増加関数であり，$1/c$の現象関数となっている。この結果の含意を理解するために，$a$はAS曲線の傾きであり，$1/c$はAD曲線の傾きであることを思い出そう。このことから次のことが言える。
# * AS曲線の傾きが急になると，長期均衡への収束速度が速くなる。
# * AD曲線の傾きが急になると，長期均衡への収束速度が遅くなる。
# 
# 同様に，式[](eq:18-eq-p-v0)と[](eq:18-eq-y-u0)を使うと次の結果を導出できる。
# 
# $$
# y_t\text{の変化率}=
# \frac{y_t}{y_{t-1}}-1=
# \frac{-cp_t}{-cp_{t-1}}-1=
# \frac{p_t}{p_{t-1}}-1=
# p_t\text{の変化率}
# $$
# 
# $p_t$と$y_t$の変化率は同じである。

# 下のプロットでは，$p_t$の初期値が負の場合を図示している。

# In[27]:


adas_model(p0=-1).plot(marker='.')
pass


# In[28]:


adas_model(p0=-1).plot('y', 'p', marker='.')
pass


# ## インパルス反応関数

# インパルス反応関数とは，ある特定のショック（$u_t$もしくは$v_t$）が発生した場合，`y_t`と`p_t`がどのように変化するかを示す時系列のグラフをである。インパルス反応関数により，ショックの波及効果を可視化できる。また，後で考察する確率的シミュレーションの結果を理解する上でも有用な情報となる。

# ### コード

# 均衡式[](eq:18-as_small)と式[](eq:18-ad_small)を再掲する。

# $$
# p_{t}=hp_{t-1}+h\left(a u_{t}+v_{t}\right)
# $$
# 
# $$
# y_t=-cp_t + u_t
# $$

# 次のコードでは，ショック項である$u_t$と$v_t$は１期間だけ変化すると仮定する。
# 従って，`u_std`と`v_std`は無関係となるため，コードには使っていない。
# 一方，`a`，`c`は上で決めた値を使うこととする。

# In[29]:


def one_period_impulse(u=0, v=0, n_after=20, a=ahat, c=chat):
    """引数
        u: AD曲線へのショックの大きさ（デフォルト：0）
        v: AS曲線へのショックの大きさ（デフォルト：0）
        n_after: ショック発生後0に戻った後の計算回数（デフォルト：20）
        a: aの値（デフォルト：ahat）
        c: cの値（デフォルト：chat）
    戻り値：
        y, p, u, vのDataFrame

    * 最初の３期間はショックゼロ"""

    # === pの差分方程式の右辺 ==========
    def price_func(p, u, v):
        h = 1/(1+a*c)
        return h*p + h*(a*u + v)
    
    # === 初期値，forループのアップデート用変数 ==========
    p = 0       # 最初は定常状態に設定
                # yの初期値は必要ない
    
    # === 結果を格納するリストの作成 ==========
    # 最初の３つの要素は定常状態に設定
    y_list = [0]*3
    p_list = [0]*3
    u_list = [0]*3
    v_list = [0]*3

    # === ショック発生時 ==========
    p = price_func(p, u, v)   # 引数のu,vが使われる
    y = - c*p + u             # 引数のuが使われる
        
    y_list.append(y)
    p_list.append(p)
    u_list.append(u)          # 引数のuが使われる
    v_list.append(v)          # 引数のvが使われる
        
    # === ショック後 ==========
    u, v = 0, 0     # ショックを0に戻す

    for _ in range(n_after):
        
        p = price_func(p, u, v)
        y = - c*p + u

        y_list.append(y)
        p_list.append(p)
        u_list.append(u)
        v_list.append(v)
    
    # === 変数の辞書 ==========
    dic = {'y':y_list, 'p':p_list, 'u':u_list, 'v':v_list}
    
    # === DataFrameを返す ==========
    return pd.DataFrame(dic)


# ### プロット

# #### 総供給ショック

# 
# 0から数えて3期目に$p_t$の１％乖離を引き起こす供給ショック（$v_t=1$）を考えよう。

# In[30]:


one_period_impulse(v=1).plot(subplots=True, marker='.')
pass


# {numref}`fig:18-adas_as_shock`を使って説明しよう。
# * $t=2$期以前は定常状態である0に経済は位置する。
# * $t=3$期にAS曲線へのショックが発生し，AS曲線が上方シフトする（①）。経済は点Aにジャンプする。
#     * $p_t$は上昇し$y_t$は減少する。
# * $t=4$期では，ショックはゼロになる。しかしAS曲線は元の位置にすぐには戻らない。適応的期待により$p_3$が高かったため$p_4$も高い傾向にあるためである。従って，$p_t$は少ししか減少しない。その結果$y_t$も少ししか縮小しない。
# * $t=5$期以降，AS曲線が徐々に下方シフトし，経済はAD曲線に沿って0に向かって動いていく（②）。
#     * $p_t$は減少し$y_t$は増加する。

# ```{figure} /images/asas_as_shock.jpeg
# ---
# scale: 35%
# name: fig:18-adas_as_shock
# ---
# 総供給ショックによるインパルス反応
# ```

# #### 総需要ショック

# In[31]:


one_period_impulse(u=1).plot(subplots=True, marker='.')
pass


# {numref}`fig:18-adas_ad_shock`を使って説明しよう。
# * $t=2$期以前は定常状態である0に経済は位置する。
# * $t=3$期にAD曲線へのショックが発生し，AD曲線が右シフトする（①）。経済は点Aにジャンプする。
#     * $p_t$と$y_t$はともに上昇する。
# * $t=4$期ではショックはゼロになり，AD曲線は元の位置に戻る（②）。一方，$p_3$が高かったため，その影響によりAS曲線は上方シフト（③），経済は点Bにジャンプする。$p_t$は減少するが高止まりする一方，$y_t$は0を下回る。
# * $t=5$期以降，AS曲線が徐々に下方シフトし，経済はAD曲線に沿って0に向かって動いていく（④）。
#     * $p_t$は減少し$y_t$は増加する。

# ```{figure} /images/asas_ad_shock.jpeg
# ---
# scale: 35%
# name: fig:18-adas_ad_shock
# ---
# 総需要ショックによるインパルス反応
# ```

# #### 総供給・総需要ショックの同時発生

# In[32]:


one_period_impulse(u=1, v=1).plot(subplots=True, marker='.')
pass


# {numref}`fig:18-adas_adas_shock`を使って説明しよう。
# * $t=2$期以前は定常状態である0に経済は位置する。
# * $t=3$期にAD曲線とAS曲線へのショックが発生し，AD曲線は右シフトし，AS曲線は上方シフトする（①）。経済は点Aにジャンプする。
#     * $p_t$と$y_t$はともに上昇する。
# * $t=4$期ではショックはゼロになり，AD曲線は元の位置に戻る（②）。一方，$p_3$が高かったため，適応的期待によりAS曲線は大きくは下落せずオレンジ色の線に下方シフトし，経済は点Bに移る。
#     * $p_t$は減少するが高止まりする一方，$y_t$は0を下回る。
# * $t=5$期以降，AS曲線が徐々に下方シフトし，経済はAD曲線に沿って0に向かって動いていく（③）。
#     * $p_t$は減少し$y_t$は増加する。

# ```{figure} /images/asas_adas_shock.jpeg
# ---
# scale: 35%
# name: fig:18-adas_adas_shock
# ---
# 総需要ショックと総供給ショックの同時発生によるインパルス反応
# ```

# ## 確率的シミュレーション

# インパルス反応関数の分析では，ショックが１期間のみ発生した場合を考え$p_t$と$y_t$の動きを考察した。
# ADASモデルの特徴を理解する上では非常に有用な分析方法である。
# 一方で，現実経済では大小の総需要・総供給ショックが毎期毎期連続的に発生していると考えることができるとともに，その結果としてデータに景気循環という形で現れていると解釈できる。
# この節では，そのような状況を再現する確率的シミュレーションをおこなうことが一つの目的である。
# もう一つの目的は，確率的シミュレーションによって生成された$p_t$と$y_t$のデータが実際の景気循環のデータをどの程度再現できるかを考察することである。データの再現性の程度によって，理論モデルとしてのADASモデルの「精度」を考えてみようということである。
# 
# ここでは総需要・総供給ショックに関して次の仮定を置く。毎期$u_t$と$v_t$は正規分布に従って発生する。
# 
# $$
# u_t\sim N(0,\sigma_u^2)
# \qquad\quad
# v_t\sim N(0,\sigma_v^2)
# $$
# 
# この仮定は次のことを意味する。
# * 正規分布により，大小の様々なショックを捉えることができる。また，小さなショックと比べて大きなショックは発生し難い。
# * ショックの幅は標準偏差である$\sigma_u$と$\sigma_v$で捉えることができる。
# * 平均を0とすることにより，$p_t$と$y_t$の長期的な値も0に設定することができる。

# ### コード

# $a$，$c$，$\sigma_u$，$\sigma_v$には，カリブレーションで得た値を使うこととする。

# In[33]:


def stochastic_sim(n=100, a=ahat, c=chat, ustd=u_std, vstd=v_std):
    """
    引数：
        n: シミュレーションの回数（デフォルト：100）
        a: aの値（デフォルト：ahat）
        c: cの値（デフォルト：chat）
        ustd: 需要ショックの標準偏差（デフォルト：u_std）
        vstd: 供給ショックの標準偏差（デフォルト：v_std）
    戻り値：
        y, p, u, vのDataFrame"""
    
    # === pの差分方程式の右辺 ==========
    def price_func(p, u, v):
        h = 1/(1+a*c)
        return h*p + h*(a*u + v)
    
    # === 初期値，forループのアップデート用変数 ==========
    p = 0   # 最初は定常状態に設定
            # yの初期値は必要ない

    # === 結果を格納するリストの作成 ==========
    y_list = []
    p_list = []
    u_list = []
    v_list = []
    
    # === ランダム変数の「種」==========
    rng = np.random.default_rng()

    # === ループ計算 ==========
    for _ in range(n):
        # ADのショック項
        u = rng.normal(0, ustd)

        # ASのショック項
        v = rng.normal(0, vstd)
        
        p = price_func(p, u, v)
        y = -c*p + u
            
        y_list.append(y)
        p_list.append(p)
        u_list.append(u)
        v_list.append(v)
            
    # === 変数の辞書 ==========
    dic = {'y':y_list, 'p':p_list, 'u':u_list, 'v':v_list}

    # === DataFrameを返す ==========
    return pd.DataFrame(dic)


# ```{caution}統計学では変数$x$が正規分布に従う場合，$x\sim N(\mu,\sigma^2)$と表す。$\mu$は平均であり，$\sigma^2$は分散を指す。一方で，上のコードの中の正規分布のランダム変数を生成するコードでは，例えば，`v=rng.normal(0, vstd)`となっており，`0`は平均であり，`vstd`は標準偏差が引数となっている。分散と標準偏差は似て異なる概念なので注意して使い分けするように。
# ```

# ### プロット

# まずループ計算を100回おこなうシミュレーションの結果をプロットしてみよう。

# In[34]:


sim = stochastic_sim(n=100)
sim.plot(subplots=True)
pass


# $u_t$と$v_t$が毎期毎期変動しており，その結果として$p_t$と$y_t$が変動していることになる。
# 視覚的に$p_t$は持続性が強いように見えるが，適応的期待の役割が大きいと考えられる。
# 
# このようなシミュレーションをおこなう上で注意する点がある。
# ランダム変数を生成させた結果となるため，実行する度に$p_t$，$y_t$，$u_t$，$v_t$の値は異なり，プロットは異なるものとなる。従って，シミュレーションの度に平均や標準偏差は異なる値になり，特に計算回数が少ない場合に問題となる。
# 解決方法は簡単で，単純にループ計算の回数を大きな値にすることである。
# （例えば，サイコロを$n$回投げて平均を計算するとしよう。$n=10$だと理論上の平均である3.5にはならない場合が多い。しかし，$n=100,000$の場合の平均は何回試行ても3.5に非常に近い値になる。）
# 
# では，10万回のシミュレーションをプロットしてみよう。

# In[35]:


sim = stochastic_sim(n=100_000)
sim.plot(subplots=True, linewidth=0.1)
pass


# このプロットから次の点を確認できる。
# * $u_t$は概ね$(-0.05,0.05)$の間に収まっているが，$v_t$の変動幅はその1/2程である。これは`u_std`と`v_std`の値の反映と言える。
# * $y_t$も概ね$(-0.05,0.05)$の間に収まっているが，$p_t$の変動幅は$y_t$よりも小さいように見える。
# * ４つの変数全てにおいて0を中心に左右対称に分布している。
# 
# このシミュレーション結果を用いて統計的な特徴を計算し，実際のデータの特徴１〜３をどの程度再現できるかを考察しよう。

# ### GDPと価格水準の％乖離の標準偏差

# **データの値（再掲）**

# In[36]:


print(f'GDPのトレンドからの％乖離の標準偏差：{y_std:.5f}')
print(f'デフレータのトレンドからの％乖離の標準偏差：{p_std:.5f}')


# **シミュレーションの結果**

# In[37]:


for value in ['y','p']:
    print(f'{value}の標準偏差:{sim[value].std():.5f}')


# * GDPの標準偏差はデータと近い値になっている。
# * 価格水準の標準偏差は大きすぎる結果となている。

# ### 自己相関係数

# **データの値（再掲）**

# In[38]:


print(f'GDPのトレンドからの％乖離の自己相関係数：{y_autocorr:.3f}')
print(f'デフレータのトレンドからの％乖離の自己相関係数：{p_autocorr:.3f}')


# **シミュレーションの結果**

# In[39]:


for value in ['y','p']:
    print(f'{value}:{sim[value].autocorr():.3f}')


# * `y`の自己相関係数は低すぎる。持続性が捉えられていない。
# * `p`の自己相関係数はデータと近い値になっており，`p`の持続性が再現されている。

# ### `p`と`y`の％乖離の相関係数：同時期

# **データの値（再掲）**

# In[40]:


df.loc[:,['gdp_cycle', 'deflator_cycle']].corr().iloc[0,1]


# **シミュレーションの結果**

# In[41]:


sim[['y', 'p']].corr().iloc[0,1]


# * 符号は合っており，数値も的外れな値ではない。

# ### 結果のまとめと拡張

# データと`100,000`回のシミュレーション結果

# |             | GDP標準偏差 | デフレータの標準偏差 | GDP自己相関係数 | デフレータの自己相関係数| GDPとデフレータの相関係数|
# |-------------|-----------|--------------|-------------- |----------------|---------|
# |データ        |  0.01477    | 0.00696        |  0.681        |    0.829       |  -0.234  |
# |WNショック    |  0.01356    | 0.01128       |  0.075       |  0.800         |  -0.166 |
# |AR(1)ショック | 0.01252     | 0.01707        |  0.649        |  0.931        |  -0.292   |

# WNショックのWNはホワイト・ノイズを表しており，上のシミュレーションの結果を示している。データの数値と比べてみよう。
# * GDP標準偏差の自己相関係数は概ね近い値（◯）
# * デフレータの標準偏差の値は高すぎる（X）
# * GDPの自己相関係数は低すぎる（X）
# * デフレータの自己相関係数は近い値（◯）
# * 同期のGDPと価格の相関係数は的外れではない（△）
# 
# 捉えることができていないデータの特徴もある一方，全く的外れな結果ではない。
# 単純なAD-ASモデルにしてはまずまずの結果と言えるのではないだろうか。

# 次に，モデルの簡単な拡張に触れる。ホワイト・ノイズは前期のショックと今期のショックは何の関係もない独立を意味する。総需要ショックと総供給ショックは，そうなのだろうか。例えば，政府支出を考えてみよう。政府は，増税を実施すると，１四半期後に減税するような行動は取らない。少なくともある期間，政策を一貫して実施することになる。投資はどうだろうか。１四半期毎に企業は投資をコロコロと変えるような行動はしない。消費者の嗜好の変化も需要ショックとして現れるが，ファッションで今季は赤が流行り，１四半期後には青が流行るということではない。すなわち，ショックはホワイト・ノイズではなく，ある程度の**持続性**が存在すると想定できる。総供給ショックも同じように考えることができる。
# 
# この特徴を捉えるために，総需要ショックと総供給ショックに次の自己回帰モデルを想定することができる。
# 
# $$
# v_t=\rho_v v_{t-1}+e^v_t,\qquad e^v_t\sim\text{WN}(0,\sigma_{ev}^2)
# $$ (eq:18-v_ar1)
# 
# $$
# u_t=\rho_u u_{t-1}+e^u_t,\qquad e^u_t\sim\text{WN}(0,\sigma_{eu}^2)
# $$ (eq:18-u_ar1)
# 
# 新たなパラメーターとして$\rho_u$，$\rho_v$，$\sigma_{eu}^2$，$\sigma_{ev}^2$の４つがあるが，これらもデータを使って次のように推定することが可能である。
# 1. 式[](eq:18-vt)の$\hat{v}$を使い，式[](eq:18-v_ar1)を推定式として$\hat{\rho}_v$を推定する。またその残差の標準偏差を$\sigma_{ev}$とする。
# 1. 式[](eq:18-ut)の$\hat{u}$を使い，式[](eq:18-u_ar1)を推定式として$\hat{\rho}_u$を推定する。またその残差の標準偏差を$\sigma_{eu}$とする。
# 
# このように計算すると次の値となる。
# * $\hat{\rho}_u=0.6884968624035948$
# * $\hat{\rho}_v=0.31284420357447135$
# * $\hat{\sigma}_{eu}=0.010415370807183315$
# * $\hat{\sigma}_{ev}=0.006036417181315$

# これらの値を使い`100,000`回シミュレーションした結果が上の表の「AR(1)ショック」に示されている。次のように結果をまとめることができる。
# * GDP標準偏差の自己相関係数は少し低い（△）
# * デフレータの標準偏差の値は高すぎる（X）
# * GDPの自己相関係数は概ね近い値（◯）
# * デフレータの自己相関係数は若干高い値（△）
# * 同期のGDPと価格の相関係数は概ね近い値（◯）

# ホワイト・ノイズの場合と比べると，AR(1)のケースが若干ではあるが再現性が向上したようにも見える。例えば，GDPの自己相関係数は格段にデータの値に近づいた。一方で，デフレーターの標準偏差の再現性はホワイト・ノイズの場合よりも悪くなっている。AR(1)のショックを導入しても再現性の著しい向上とは言えないだろう。

# ### ADASモデルの評価

# ADASモデルは，経済を理解する上では非常に有用だが，データの一部の特徴の説明力に欠ける。
# どう評価すれば良いだろうか。
# 
# 経済学研究で用いる推論方法を考えてみよう。
# 帰納的推論（inductive inference）とは，真のモデルが存在するという前提の下でデータを使い推定するモデルの蓋然性を検討する手法である。
# 典型的な例として，計量経済分析が当てはまる。
# 推定されたモデルは，帰納的推論の**アウトプット**ということになる。

# ```{figure} /images/inductive.png
# ---
# scale: 35%
# name: fig:18-inductive
# ---
# 帰納的推論
# ```

# 一方，演繹的推論（deductive inference）では，モデルは**インプット**になる。
# モデルを「装置」として使い，理論の含意に関して推論しようということである。
# 例えば，ADASモデルで比較静学をおこない，外生変数の定性的な効果を検討する場合が当てはまる。
# 政府支出が増加すると実質利子率は上昇するとい結果は，ADASモデルを使った演繹的推論の結果である。
# しかし，経済モデルは複雑な経済を抽象化した考え方に過ぎず，ADASモデルを含めてどのような経済モデルであっても複雑な経済の全ての側面を捉えることはできない「間違った」モデルである。
# また，この章の目的はADASモデルが真のモデルかどうかを判断しようということではない。
# 従って，データの特徴の一部を説明できないのは，単にADASモデルの限界を表していると解釈できる。

# ```{figure} /images/deductive.png
# ---
# scale: 35%
# name: fig:18-deductive
# ---
# 演繹的推論
# ```

# では，ADASモデルのどこに有用性があるのだろうか。
# カリブレーションを説明する際，手作りの体重計の例を使ったがもう一度考えみよう。
# カリブレーション後，60kg以上の体重は誤差が大きく使いものにならないが，60kg未満であれば誤差は許容範囲だとしてみよう。
# この場合，「普通の小学生やそれより幼い子どもの体重を測る」ことが目的であれば，手作り体重計の成功と考えることができる。
# 要するに，完璧な「装置」でなくとも，目的に沿ったものであれば十分だということだ。
# 「完璧でなくても良い」という考え方は，地図の有用性を考えれば直ぐに理解できるのではないだろうか。
# 地図は，実際の距離を縮尺にしており，多くの詳細が省かれている。
# 三宮のレストランを探す場合，世界地図は使いものにならない。
# しかし，石油を運ぶタンカーの運航や宇宙衛星を落下させる際には重要な役割を果たす（政治的な目的にも有用だという主張もある）。
# 経済モデルは地図のようなものであり，AD-ASモデルは不完全だが，ある目的のためであれば有用になり得るということだ。
# 
# このような演繹的推論に基づき，再現性の精度には多少欠けることも念頭に，次のセクションではADASモデルを「装置」として使い**定量的**な問を検討する。

# ## 定量的な問い

# > GDPと価格水準の％乖離の変動は，何パーセントが需要ショックにより引き起こされ，何パーセントが供給ショックに起因するのか？
# 
# この問を検討するには，定性的な比較静学では不可能であり，定量的なアプローチが要求される。では，この問にどのように答えれば良いかどうか。ここでは，ベクトル自己回帰モデルで使われる次のような手法を採用する。

# ### 予測誤差

# カリブレーションをおこなった際の推定式[](eq:18-regression-h)と[](eq:18-regression-d)を再掲する。
# 
# $$
# \begin{align*}
# y_{t} &= -chp_{t-1} + e_{yt}\\
# p_{t}&=hp_{t-1} + e_{pt}
# \end{align*}
# $$
# 
# * $e_{yt}\equiv h(u_{t}-cv_{t})$
# * $e_{pt}\equiv h\left(a u_{t}+v_{t}\right)$
# 
# 今期が$t-1$期とし，$x_{t-1}$は既に実現したと考えてみよう。一方，$t$期の変数は実現前の将来の変数としよう。ここで，実現値$x_{t-1}$を所与として`t`期の変数を予測するとしよう。予測値は次式で表現できる。
# 
# $$
# \begin{align*}
# \text{E}_{t-1}(y_{t}) &= -chp_{t-1}\\
# \text{E}_{t-1}(p_{t})&=hp_{t-1}
# \end{align*}
# $$
# 
# $\text{E}_{t-1}$は$t-1$時点での情報に基づき期待値を計算していることを表す。また，$u_t$と$v_t$の期待値（平均）はゼロと仮定しているため，$\text{E}_{t-1}(u_t)=\text{E}_{t-1}(v_t)=0$となり，$\text{E}_{t-1}(e_{yt})=\text{E}_{t-1}(e_{pt})=0$も成立することになり，上の予測値の結果となる。
# 
# 更に，上の２つの式を使うと，予測誤差を次のように表すことができる。
# 
# $$
# \begin{align*}
# y_{t} - \text{E}_{t-1}(y_{t})&= e_{yt}\\
# p_{t}- \text{E}_{t-1}(p_{t})&= e_{pt}
# \end{align*}
# $$
# 
# この結果は，次のことを意味する。
# * 予測誤差は$e_{yt}$と$e_{pt}$に集約される。
# * 予測誤差は総需要ショックと総供給ショックによって発生した$y_t$と$p_t$の変動を捉えており，両方の影響が混在する。

# 次に，予測誤差に基づいて総需要・総供給ショックの影響を抽出する計算方法ついて下で説明するが，その前に，その考え方について簡単に説明する。確率的シミュレーションが示すように，ショックが連続して発生することにより，$y_t$と$p_t$はトレンド（$y_*=p_*=0$）には戻らず，％乖離は正や負の値を取ることになる。そのような変動の大きさは分散で捉えることができる。同様に，予測誤差の変動もその分散で捉えることができ，更には，総需要ショックと総供給ショックの分散に依存することになる。即ち，次のように分散分解することができる。
# 
# $$
# \text{Var}(e_{xt})=\text{Var}(e_{xt}|u_t)+\text{Var}(e_{xt}|v_t)
# \qquad
# x_t=y_t,p_t
# $$
# 
# * $\text{Var}(e_{xt})$：$x_t$の分散
# * $\text{Var}(e_{xt}|u_t)$：総需要ショック（$u_t$）に起因する$x_t$の分散
# * $\text{Var}(e_{xt}|v_t)$：総供給ショック（$v_t$）に起因する$x_t$の分散
# 
# この関係を使うと，何％が需要ショックに起因し，残りの何％が供給ショックにより発生しているかは次式で与えられることになる。
# 
# $$
# \begin{align*}
# \left(
# \begin{split}
# &\text{総需要ショックによる}\\
# &x_t\text{の変動の割合}
# \end{split}
# \right)
# &=
# \frac{\text{Var}(e_{xt}|u_t)}{\text{Var}(e_{xt})},
# \qquad
# x_t=y_t,p_t
# \\
# \left(
# \begin{split}
# &\text{総供給ショックによる}\\
# &x_t\text{の変動の割合}
# \end{split}
# \right)
# &=
# \frac{\text{Var}(e_{xt}|v_t)}{\text{Var}(e_{xt})},
# \qquad
# x_t=y_t,p_t
# \end{align*}
# $$
# 
# 以下では，それぞれの項を計算し量的な問いを考察する。

# ### GDPの％乖離

# #### 計算方法

# 予測誤差$e_{yt}$は次式で与えられる。
# 
# $$
# e_{yt}=h(u_t-cv_t)
# $$

# 両辺の分散を計算すると次のようになる。
# 
# $$
# \begin{align*}
# \text{Var}(e_{yt})
# &=\text{Var}(hu_{t}-chv_{t})\\
# &=\text{Var}(hu_{t})+
#     \text{Var}(-chv_{t})+
#     2\text{Cov}(hu_{t},-chv_{t})\\
# &=h^2\text{Var}(u_{t})+
#     (ch)^2\text{Var}(v_{t})-
#     2ch^2\text{Cov}(u_{t},v_{t})\\
# &=h^2\sigma_u^2+
#     (ch)^2\sigma_v^2-
#     2ch^2\sigma_{uv}\\
# &\quad\Downarrow\\
# &=\text{Var}(e_{pt}|u_t)+\text{Var}(e_{pt}|v_t)
# \end{align*}
# $$

# ここで
# * $\sigma_u^2=\text{Var}(u_{t})$ は$u_t$の分散
# * $\sigma_v^2=\text{Var}(v_{t})$ は$v_t$の分散
# * $\sigma_{uv}=\text{Cov}(u_t,v_t)$ は$u_t$と$v_t$の共分散
# 
# であり，
# 
# $$
# \text{Var}(e_{yt}|u_t)
# =h^2\left(\sigma_u^2-c\sigma_{uv}\right)
# $$ (eq:18-var-eyu)
# 
# は需要ショックによる$e_{yt}$の分散であり，
# 
# $$
# \text{Var}(e_{yt}|v_t)
# =h^2\left(c^2\sigma_v^2-c\sigma_{uv}\right)
# $$ (eq:18-var-eyv)
# 
# は供給ショックによる$e_{yt}$の分散である。上の式の４行目にある$-2ch^2\sigma_{uv}$は，需要ショックと供給ショックが連動する効果を捉えているため，$\text{Var}(e_{yt}|u_t)$と$\text{Var}(e_{yt}|v_t)$に等分している。

# この結果を使うと，
# 
# $$
# \begin{align*}
# \left(
# \begin{split}
# &\text{需要ショックによる}\\
# &y_t\text{の変動の割合}
# \end{split}
# \right)
# &=\frac{\text{Var}(e_{yt}|u_t)}{\text{Var}(e_{yt})}
# =\frac{\sigma_u^2-c\sigma_{uv}}
#     {\sigma_u^2+
#     c^2\sigma_v^2-
#     2c\sigma_{uv}}
# \tag{*y}
# \end{align*}
# $$

# $$
# \begin{align*}
# \left(
# \begin{split}
# &\text{供給ショックによる}\\
# &y_t\text{の変動の割合}
# \end{split}
# \right)
# &=\frac{\text{Var}(e_{yt}|u_t)}{\text{Var}(e_{yt})}
# =\frac{c^2\sigma_v^2-c\sigma_{uv}}
#     {\sigma_u^2+
#     c^2\sigma_v^2-
#     2c\sigma_{uv}}
# \tag{**y}
# \end{align*}
# $$

# 計算結果を見て気付くのは，総需要曲線の傾きである $c$ が重要な役割を果たしている。一方，総供給曲線の傾きである $a$ は，変動の大きさ（即ち，分散の大きさ）に影響を及ぼすが（$h=1/(1+ac)$を思い出そう），変動の割合は $a$ から独立であることがわかる。

# #### 結果

# それぞれの変数の推定値を使い実際に計算してみよう。

# In[42]:


# 式(*y)の分子
numerator_y = ut.var() - chat*np.cov(ut,vt)[0,1]
# 式(*y)の分母
denominator_y = ut.var() + chat**2*vt.var() - 2*chat*np.cov(ut,vt)[0,1]

ad_shock_on_y = numerator_y / denominator_y
print(f'GDPの％乖離の{100*ad_shock_on_y:.1f}％は総需要ショックに起因する。'  )


# In[43]:


print(f'GDPの％乖離の{100*(1-ad_shock_on_y):.1f}％は総供給ショックに起因する。'  )


# GDPの％乖離に対しては総需要ショックが相対的に大きな影響を及ぼしていることがわかる。

# #### 解釈

# まず，式[](eq:18-var-eyu)の需要ショックによる$y_t$の変動の大きさ（割合ではない）を考えてみよう。式を展開すると
# 
# $$
# \text{Var}(e_{yt}|u_t)
# =h^2\sigma_u^2-ch^2\sigma_{uv}
# $$
# 
# となる。右辺の第１項は，総供給曲線を所与として需要ショックによる$y_t$の変動を捉えている。
# 第２項 $-ch^2\sigma_{uv}>0$ は，需要ショックと供給ショックが同時に変動する影響を捉えている。計算すると正の値になることは簡単に確認できる。即ち，正の需要ショック（$u_t>0$）は負の供給ショック（$v_t<0$）を伴う傾向にあり，$y_t$に対する需要ショックの効果は，伴う供給ショックによって増幅されることを意味する。
# 
# 同様に，式[](eq:18-var-eyv)の供給ショックによる$y_t$の変動を考えてみよう。
# 
# $$
# \text{Var}(e_{yt}|v_t)
# =(ch)^2\sigma_v^2-ch^2\sigma_{uv}
# $$
# 
# 右辺の第１項は，需要曲線を所与として供給ショックが変動する場合の $y_t$ の変動を捉えている。
# 第２項 $-ch^2\sigma_{uv}>0$ は，正の供給ショック（$v_t>0$）は負の需要ショック（$u_t<0$）を伴う傾向にあり，$y_t$に対する供給ショックの効果は，需要ショックによって増幅されている。
# 
# 変動の大きさを決定する上で，$h$ が重要な役割を果たしている。$h$はは約`0.8`であり$p_t$の高い持続性を意味する。持続性が高い場合，一旦総供給曲線が定常状態の位置から離れると元の位置に戻るには時間が掛かることになる。即ち，定常状態から離れた状態が長くなる。そのような状況下で，更にショックが発生すると，定常状態から更に乖離する結果につながることになる。このメカニズムにより，$h$が高くなると，両方のショックの影響は増幅されることになる。その効果が $h^2$ で捉えられている。

# 次に，割合を考えてみよう。価格水準の％乖離に対しては総供給ショックが相対的に大きな影響を及ぼしていることがわかるが，式(\*y)と(\*\*y)にはあるパラメータは $c$のみであり，その役割を考えてみよう。総需要曲線の傾きは $1/c$で与えられる。
# {numref}`fig:18-y-uv`では，AD曲線の傾きが急な場合と緩やかな場合の２つのケースを示している。
# * $1/c$ が小さいケース：
#     * 総需要曲線の傾きは緩やかになる。
#     * 総供給曲線が動くと$y_t$は大きく動くが，$p_t$は大きく動かない。
# * $1/c$ が大きいケース：
#     * 総需要曲線の傾きは急になる。
#     * 総供給曲線が動くと$y_t$の動きは小さくなる一方，$p_t$は大きく動くことになる。
# 
# $1/c$ の値は`1`よりも大きく，$1/c$ が大きいケースが当てはまる。この場合，$y_t$に対する総供給ショックのインパクトは小さな値となり，相対的に総需要ショックの寄与度が高くなっていると考えられる。

# ```{figure} /images/adas-y-uv.jpeg
# ---
# scale: 35%
# name: fig:18-y-uv
# ---
# GDPの％乖離の変動において総需要ショックの影響が大きい理由
# ```

# ### 価格水準の％乖離

# #### 計算方法

# $e_{pt}$は次式で与えられる。
# 
# $$
# e_{pt}=ahu_t+hcv_t
# $$

# 両辺の分散を計算すると次のようになる。
# 
# $$
# \begin{align*}
# \text{Var}(e_{pt})
# &=\text{Var}(ahu_{t}+hv_{t})\\
# &=\text{Var}(ahu_{t})+
#     \text{Var}(hv_{t})+
#     2\text{Cov}(ahu_{t},hv_{t})\\
# &=(ah)^2\text{Var}(u_{t})+
#     h^2\text{Var}(v_{t})+
#     2ah^2\text{Cov}(u_{t},v_{t})\\
# &=(ah)^2\sigma_u^2+
#     h^2\sigma_v^2+
#     2ah^2\sigma_{uv}\\
# &\quad\Downarrow\\
# &=\text{Var}(e_{pt}|u_t)+\text{Var}(e_{pt}|v_t)
# \end{align*}
# $$

# ここで
# 
# $$
# \text{Var}(e_{pt}|u_t)
# =h^2\left(a^2\sigma_u^2+a\sigma_{uv}\right)
# $$ (eq:18-var-epu)
# 
# は需要ショックによる$e_{pt}$の分散であり，
# 
# $$
# \text{Var}(e_{pt}|v_t)
# =h^2\left(\sigma_v^2+a\sigma_{uv}\right)
# $$ (eq:18-var-epv)
# 
# は供給ショックによる$e_{pt}$の分散である。上の式の４行目にある$2ah^2\sigma_{uv}$は，需要ショックと供給ショックが連動する効果を捉えているため，$\text{Var}(e_{pt}|u_t)$と$\text{Var}(e_{pt}|v_t)$に等分している。

# この結果を使うと，
# 
# $$
# \begin{align*}
# \left(
# \begin{split}
# &\text{需要ショックによる}\\
# &p_t\text{の変動の割合}
# \end{split}
# \right)
# &=\frac{\text{Var}(e_{pt}|u_t)}{\text{Var}(e_{pt})}
# =\frac{a^2\sigma_u^2+a\sigma_{uv}}
#     {a^2\sigma_u^2+
#     \sigma_v^2+
#     2a\sigma_{uv}}
# \tag{*p}
# \end{align*}
# $$

# $$
# \begin{align*}
# \left(
# \begin{split}
# &\text{供給ショックによる}\\
# &p_t\text{の変動の割合}
# \end{split}
# \right)
# &=\frac{\text{Var}(e_{pt}|u_t)}{\text{Var}(e_{pt})}
# =\frac{\sigma_v^2+a\sigma_{uv}}
#     {a^2\sigma_u^2+
#     \sigma_v^2+
#     2a\sigma_{uv}}
# \tag{**p}
# \end{align*}
# $$

# 計算結果を見て気付くのは，総供給曲線の傾きである $a$ が重要な役割を果たしている。一方，総需要曲線の傾きである $c$ は，変動の大きさ（即ち，分散の大きさ）に影響を及ぼすが（$h=1/(1+ac)$を思い出そう），変動の割合は`c`から独立であることがわかる。

# #### 結果

# それぞれの変数の推定値を使い実際に計算してみよう。

# In[44]:


# 式(*p)の分子
numerator_p = ahat**2*ut.var() + ahat*np.cov(ut,vt)[0,1]
# 式(*p)の分母
denominator_p = ahat**2*ut.var() + vt.var() + 2*ahat*np.cov(ut,vt)[0,1]

ad_shock_on_p = numerator_p / denominator_p
print(f'価格水準の％乖離の{100*ad_shock_on_p:.1f}％は需要ショックに起因する。'  )


# In[45]:


print(f'価格水準の％乖離の{100*(1-ad_shock_on_p):.1f}％は供給ショックに起因する。'  )


# 価格水準の％乖離に対しては総供給ショックが相対的に大きな影響を及ぼしていることがわかる。

# #### 解釈

# まず，式[](eq:18-var-epu)の需要ショックによる$p_t$の変動（割合ではない）を考えてみよう。
# 式を展開すると
# 
# $$
# \text{Var}(e_{pt}|u_t)
# =(ah)^2\sigma_u^2+ah^2\sigma_{uv}
# $$
# 
# となる。右辺の第１項は，供給曲線を所与として需要ショックによる$p_t$の変動を捉えている。
# 第２項 $ah^2\sigma_{uv}<0$ は，需要ショックと供給ショックが同時に変動する影響を捉えている。計算すると負の値になることは簡単に確認できる。即ち，正の需要ショック（$u_t>0$）は負の供給ショック（$v_t<0$）を伴う傾向にあり，$p_t$に対する需要ショックの効果は，伴う供給ショックによって減衰されることを意味する。
# 
# 同様に，式[](eq:18-var-epv)の供給ショックによる$p_t$の変動を考えてみよう。
# 
# $$
# \text{Var}(e_{pt}|v_t)
# =h^2\sigma_v^2+ah^2\sigma_{uv}
# $$
# 
# 右辺の第１項は，需要曲線を所与として供給ショックが変動する場合の $p_t$ の変動を捉えている。
# 第２項 $ah^2\sigma_{uv}<0$ は，正の供給ショック（$v_t>0$）は負の需要ショック（$u_t<0$）を伴う傾向にあり，$p_t$に対する供給ショックの効果は，需要ショックによって減衰されている。
# 
# 変動の大きさを決定する上で，$h$ が重要な役割を果たしているが，上で説明した通りである。

# 次に，割合を考えてみよう。価格水準の％乖離に対しては総供給ショックが相対的に大きな影響を及ぼしていることがわかるが，式(\*p)と(\*\*p)にはあるパラメータは`a`（総供給曲線の傾き）のみであり，その役割を考えてみよう。
# {numref}`fig:18-p-uv`では，AS曲線の傾きが急な場合と緩やかな場合の２つのケースを示している。
# * $a$ が小さい場合，総供給曲線の傾きは緩やかになる。その場合，需要曲線が動くと$y_t$は大きく動くが，$p_t$は大きく動かない。
# * $a$ が大きい場合，総供給曲線の傾きは急になる。その場合，需要曲線が動くと$y_t$の動きは小さくなる一方，$p_t$は大きく動くことになる。
# 
# $a$ の値は`1`よりも小さく，$a$ が小さいケースが当てはまる。この場合，$p_t$に対する総需要ショックのインパクトは小さな値となり，相対的に総供給ショックの寄与度が高くなっていると考えられる。

# ```{figure} /images/adas-p-uv.jpeg
# ---
# scale: 35%
# name: fig:18-p-uv
# ---
# 物価水準の％乖離の変動において総供給ショックの影響が大きい理由
# ```

# ## まとめ

# GDPと価格水準のトレンドからの％乖離のプロットを再掲する。

# In[46]:


ax_ = df.loc[:,['gdp_cycle','deflator_cycle']].plot()
ax_.axhline(0, color='red')
pass


# このプロットを眺めることにより，総需要ショックと総供給ショックがどれだけ景気循環に影響を及ぼしているかが分かるだろうか。もちろん否である。ADASモデルを「装置」として用いて，「スイッチ」を調整することにより，結果が数字として現れてくることになる。
# 「調整済み装置」があってこその分析結果であり，体重計がないと体重を測れないことと同じである。
# 
# 体重計の例をもう一度考えてみよう。
# 今度は，AさんとBさんが作る体重計である。
# Aさんの体重計は単純な装置だが，一方，Bさんの技術は高く，設計図は洗練され使う材料もより質が高いとしてみよう。
# その差は精度の違いとして現れることになるだろう。
# マクロ経済モデルも同じである。
# AD-ASモデルは，研究や政策議論で使われるモデルと比べると単純なモデルであり，それが故に定量的な問に対しての答えも精度が低いものとならざるを得ない。
# 大学院で学ぶDSGEモデルや構造VARモデルなどはより洗練された「装置」であり，AD-ASモデルよりも精度が高い結果を返すことになるだろう。

# ## 付録：分散と共分散の性質

# $X$，$Y$，$Z$，$W$をランダム変数，$a$，$b$，$c$，$d$を定数とする。
# 分散に関して次の結果が成立する。
# 
# $$
# \begin{align*}
# \text{Var}(k)&=0\\
# \text{Var}(X+k)&=\text{Var}(X)\\
# \text{Var}(aX)&=a^2\text{Var}(X)\\
# \text{Var}(aX\pm bY)&=a^2\text{Var}(X)+b^2\text{Var}(Y)\pm 2ab\text{Cov}(X,Y) \\
# \end{align*}
# $$

# 共分散に関して次の結果が成立する。
# 
# $$
# \begin{align*}
# \text{Cov}(X,a)&=0\\
# \text{Cov}(X,X)&=\text{Var}(X)\\
# \text{Cov}(aX,bY)&=ab\text{Var}(Y,X)\\
# \text{Cov}(X+a,Y+b)&=\text{Var}(Y,X)\\
# \text{Cov}(aX+bY,cZ+dW)&=ac\text{Cov}(X,Z)+ad\text{Cov}(X,W)+bc\text{Cov}(Y,Z)+bd\text{Cov}(Y,W)
# \end{align*}
# $$
